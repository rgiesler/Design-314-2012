/***********************************************************************/
/*                                                                     */
/*  FILE        :intprg.c                                              */
/*  DATE        :Tue, Feb 07, 2012                                     */
/*  DESCRIPTION :define the top address of the interrupt vectors.      */
/*  CPU GROUP   :27                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.18).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

/***************************************************************************
 *  COMPILER for M16C/60,R8C/Tiny
 *  Copyright(c) 2004 Renesas Technology Corp.
 *  And Renesas Solutions Corp.,All Rights Reserved. 
 *  intprg.c : define variable vector table
 *		for R8C/27,26
 *
 *
 * $Date: 2006/09/13 05:29:23 $
 * $Revision: 1.3 $
 **************************************************************************/
#include "sfr_r827.h"
#include "cstartdef.h"
#include "serial.h"
volatile unsigned char timer_a_count=0;
volatile unsigned char sec=0;
volatile unsigned char halfsec=0;
volatile unsigned char serial1_message=0;
// When you want to use BANK1 registers
// please define interrupt using /B swtich as follows.
//
//  #pragma interrupt/B xxxx
//

// BRK				(software int 0)

#pragma interrupt	_brk(vect=0)
void _brk(void){}

// vector 1 reserved
// vector 2 reserved
// vector 3 reserved
// vector 4 reserved
// vector 5 reserved
// vector 6 reserved

// timer RC (channel 0)		(software int 7)
#pragma interrupt	_timer_rc(vect=7)
void _timer_rc(void){}

// vector 8 reserved
// vector 9 reserved

// timer RE			(software int 10)
#pragma interrupt	_timer_re(vect=10)
void _timer_re(void){}

// vector 11 reserved
// vector 12 reserved

// input_key			(software int 13)
#pragma interrupt	_input_key(vect=13)
void _input_key(void){}

// A-D converter		(software int 14)
#pragma interrupt	_ad_converter(vect=14)
void _ad_converter(void){}

// SSU  IIC			(software int 15)
#pragma interrupt	_ssu(vect=15)
void _ssu(void){}

// vector 16 reserved

#if defined (__STANDARD_IO__) && (defined(__FOUSB__) ||  defined(__E8__))
// uart0 can't be used
#else
// uart0 trance			(software int 17)
#pragma interrupt	_uart0_trance(vect=17)
void _uart0_trance(void){}
#endif

// uart0 receive		(software int 18)
#pragma interrupt	_uart0_receive(vect=18)
void _uart0_receive(void){}

#if defined(__STANDARD_IO__) || defined(__FOUSB__) || defined(__E8__)
// uart1 can't be used
#else
// uart1 trance			(software int 19)
#pragma interrupt	_uart1_trance(vect=19)
void _uart1_trance(void){}
#endif

// uart1 receive		(software int 20)
/* This interrupt gets called whenever a byte is recieved over
   the serial port. It writes the byte into the 'serial1_message'
   variable, which is polled by the main function.  */
#pragma interrupt	_uart1_receive(vect=20)
void _uart1_receive(void)
{ serial1_message=u1rbh;
  serial1_message=u1rbl;
}

// vector 21 reserved

// timer RA			(software int 22)
/* This timer is set to 100 Hz. It increments two variables,
   'sec', which it increments every second, and 'halfsec',
   which it increments every half second. Both of these are
   used within the main function */
#pragma interrupt	_timer_ra(vect=22)
void _timer_ra(void)
{ timer_a_count++;
  if (100==timer_a_count)
  { sec ++;
    halfsec++;
    timer_a_count=0;
  }
  if (50==timer_a_count)
    halfsec++;
}

// vector 23 reserved

// timer RB			(software int 24)
#pragma interrupt	_timer_rb(vect=24)
void _timer_rb(void){}

// int1				(software int 25)
#pragma interrupt	_int1(vect=25)
void _int1(void){}

// int3				(software int 26)
#pragma interrupt	_int3(vect=26)
void _int3(void){}

// vector 27 reserved
// vector 28 reserved

// int0				(software int 29)
#pragma interrupt	_int0(vect=29)
void _int0(void){}

// vector 30 reserved
// vector 31 reserved

// vector 32 for user
// vector 33 for user
// vector 34 for user
// vector 35 for user
// vector 36 for user
// vector 37 for user
// vector 38 for user
// vector 39 for user
// vector 40 for user
// vector 41 for user
// vector 42 for user
// vector 43 for user
// vector 44 for user
// vector 45 for user
// vector 46  for user
// vector 47  for user
// vector 48  for user
// vector 49  for user
// vector 50  for user
// vector 51  for user
// vector 52  for user
// vector 53  for user
// vector 54  for user
// vector 55  for user
// vector 56  for user
// vector 57  for user
// vector 58  for user
// vector 59  for user
// vector 60  for user
// vector 61  for user
// vector 62  for user
// vector 63  for user

